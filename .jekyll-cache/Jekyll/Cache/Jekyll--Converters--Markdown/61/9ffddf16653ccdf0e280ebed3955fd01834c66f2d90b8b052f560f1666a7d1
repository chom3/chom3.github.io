I"]<h1 id="the-problem">The Problem</h1>
<p>note: from leetcode
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>

<p>Given n = 3</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Output:
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
</code></pre></div></div>

<h1 id="importance">Importance</h1>
<p>The problem itself isnâ€™t that important to remember. The algorithm and understanding how to do the algorithm is more important. Backtracking can come up in diferent ways, usually youâ€™ll have to keep in mind that you start the function with some data structure to hold the different combinations. Youâ€™ll then call a private function which will be used recursively to add a starting point and then branch off into different scenarios.</p>

<h1 id="thought-process">Thought Process</h1>
<p>The output example is most likely a list of strings so we can start there.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List&lt;String&gt; result = new ArrayList&lt;String&gt;();
// need to do something

return result;
</code></pre></div></div>

<p>Then like what was stated before, weâ€™ll need to call a function to get our recursion started.</p>

<p>In this case, we need to make sure we keep track of our â€œ(â€œ and â€œ)â€. We can call these left â€œ(â€œ and right â€œ)â€. If we initialize these values as integers, we can keep track of adding 1 to left or adding 1 to right. If left = n we stop adding left parenthesis, and if right = n we stop adding right ones.</p>

<p>As we recurse weâ€™ll pretty much be appending to our string, so we need to keep track of our string as we go on.</p>

<p>When will we know when to stop?</p>

<p>If weâ€™re given â€œn pairsâ€ then when our length is 2 * n weâ€™ll know weâ€™re done.</p>

<p>We just need to know that the parentheses are well-formed, that each parentheses pair is closed properly.</p>

<p>I think that gives us enough info on what parameters weâ€™ll need for our recursive function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parameters: 
need our List&lt;String&gt; result
int left
int right
string start
int n 

//base case - we have a well formed pair, add to our result and exit
if (2 * n == start.length()){
    result.add(start);
    return;
}

//our number of left parenthesis is less than n
//use recursion and add one to the left
if (left &lt; n){
    backtrack(result, left + 1, right, n, start+"(");
}

//same for the right
if (right &lt; n){
    backtrack(result, left, right+1, n, start+")");
}

How do we start the call? With all initial values of 0's and empty strings.
backtrack(result, 0, 0, n, "");
</code></pre></div></div>

<h1 id="solution--putting-it-all-together">Solution / Putting it all together</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; result = new ArrayList&lt;String&gt;();
                
        backtrack(result, 0,0, n, "");
        return result;
    }
    
    private void backtrack(List&lt;String&gt; result, int left, int right, int n, String start){
        if (start.length() == n*2){
            result.add(start);
            return;
        }
        if (left &lt; n){
            backtrack(result, left+1, right, n, start+"(");
        }
        if (right &lt; left){
            backtrack(result, left, right+1, n, start+")");
        }
    }
</code></pre></div></div>
:ET